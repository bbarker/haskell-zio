<table>
<colgroup>
<col style="width: 8%" />
<col style="width: 22%" />
<col style="width: 8%" />
<col style="width: 61%" />
</colgroup>
<thead>
<tr class="header">
<th>Haskell Type</th>
<th>Alias for</th>
<th>Scala Type</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ZIO r e a</code></td>
<td></td>
<td><code>ZIO[R,E,A]</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>UIO a</code></td>
<td></td>
<td><code>UIO[A]</code></td>
<td>This is a type alias in Scala but a concrete type in Haskell due to UIO being an inner monadic type.</td>
</tr>
<tr class="odd">
<td><code>EIO e a</code></td>
<td></td>
<td><code>IO[E, A]</code></td>
<td>This is a type alias in Scala but a concrete type in Haskell due to EIO being an inner monadic type.</td>
</tr>
<tr class="even">
<td><code>RIO r a</code></td>
<td><code>ZIO r SomeNonPseudoException a</code></td>
<td><code>RIO[R, A]</code></td>
<td>Same idea as in Scala. Not to be confused with the RIO libraryâ€™s <code>RIO</code> monad, but they are isomorphic.</td>
</tr>
<tr class="odd">
<td><code>Task a</code></td>
<td><code>ZIO Void SomeNonPseudoException a</code></td>
<td><code>Task[A]</code></td>
<td></td>
</tr>
<tr class="even">
<td><code>UEIO a</code></td>
<td><code>EIO Void a</code></td>
<td><code>UIO[A]</code></td>
<td></td>
</tr>
<tr class="odd">
<td><code>URIO r a</code></td>
<td><code>ZIO r Void a</code></td>
<td><code>URIO[R, A]</code></td>
<td>Same idea as in Scala; a ZIO value isomorphic to a RIO value (can be projected to the RIO value).</td>
</tr>
<tr class="even">
<td><code>UZIO a</code></td>
<td><code>ZIO Void Void a</code></td>
<td><code>UIO[A]</code></td>
<td></td>
</tr>
</tbody>
</table>
